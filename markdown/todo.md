## TODO
1, pycharm 如何使用正则表达式模式替换？
2, 制作一个工具，可以把几个项目同步到github上面；

## 要学习的内容
### 列表、字典、集合  

### 函数、装饰器

### 异常 

### 类、模式

### 正则表达式  

### pyqt

### 爬虫
> scrapy

### flask
> 扩展

### Linux
? 选择一个什么样的版本  





## 学习进度 
### 总结
1. 你应该看清，不认识的单词都是平等的，没有重要与不重要的区分；只有你会不会的区分；  
2. 你用一个大袋子把房间里的垃圾收拾着，等满了再拿下去，这也是你懒的一部分，这也是你房间垃圾迟迟不倒的原因啊。
3. 每个while里面都是一另一个时空；
4. 


### yield的理解

关于yield, 一般的生成器写法是
```python
def gen():
    for i in range(5):
        yield i 

```
yield 的左边一直是没有东西的，也就是说没有一个变量可以接收yield返回的值；似乎只有gen（）函数，也就是它的调用都可以接受生成器返回的值；
接收生成器值的过程：
1， 定义一个生成器实例，g = gen（） 
2， 用a = next（g）激活一次生成器，产生一个值， 用一个变量a来接收此值；
我们是否可以理解next就是调用者呢？

而对于 value = yield "nihao" 的形式的理解，value被赋值，表面是由yield传给它的，但是要思考yield传给它的是什么，是由哪里来的，是nihao么，不是的，应该是由调用者分发给yield，然后赋给value变量的；

所以一个生成器可以看做是一个时空，这个时空与外界的交互是通过yield来传递的；yield可以通过调用者接收一个值，也可以通过调用者向外传递一个值；

yield所在的空间可以是一个循环的空间；也可以是一个可以结束的空间；
不管是一个什么样的空间，每次运行到yield时空就要静止，这个时候，yield要向外界发送一个值；

而生成器里面的运动，是通过next激活生成器的；或者send；
send可以可以看做是两个步骤，第一，发送给生成器一个值 第二，next一下生成器；
   

### 2022.06.08 
#### english
> memento n:纪念品， 令人回忆的东西 
>weakref 弱引用
weak 弱的
vector 向量 vector vector 
store 店铺 store store 
special spcial special special 特别的
risk 风险 risk risk 
资源 
relative 相对的 relative relative relative 
建议的 proposed proposed 
平台 platform platform 
可选的 optional optional optional  optional optional
平行 parallel 对比 parallel  parallel parallel parallel 
参数 parameter  parameter parameter parameter parameter parameter
表演 perform perform  perform perform perform 
坚持 persist persist  persist persist persist persist 
picklable  picklabel 
泡菜 pickle pickle pickle pickle pickle pickle pickle pickle  
actually actually 实际上  actually actually actually actually 

### 2022.06.03 基础复习 列表，字典

### 2022.06.05 异步

Cpu的上下文切换  
为了让所有的线程、进程共享资源，CPU经常进行上下文切换。过程就是Cpu保存一个线程的上下文信息并切换到另一个线程；

异步编程的本质是软件、用户空间线程，应用程序来管理线程和上下文切换，而不是Cpu。  
在异步的世界里，上下文仅在定义的切换点而不是在不确定的时间间隔内切换。  

回调是一个函数，它的意思是“一旦完成，就执行这个函数”。它基本上是代码的“完成时”挂钩。换句话说，回拨就像您拨打客户服务热线，并立即留下您的号码并挂断，这样他们就可以在有空时给您回电，而不必永远等待

回调的另一个问题是，在异步世界中，不阻塞事物的唯一方法是使用回调。

回调吞噬异常

回调不可收集

回调后的回调变得混乱且难以调试

并发就像在单核 CPU 上运行两个线程。来自每个线程的指令可以交错，但在任何给定时间，只有两个线程中的一个正在积极取得进展。

并行性就像在多核 CPU 的不同内核上同时运行两个线程。

重要的是要注意并行性意味着并发，而不是相反

异步是一个更高级别的编程概念，您在其中触发一些任务，并决定虽然您没有该任务的结果，但您最好做一些其他工作而不是等待。

当您以异步方式执行操作时，根据定义，您意味着这些事物之间的并发性。

事件循环

这就是让一切成为可能的原因 — 一个简单的循环，就是这样。好吧，没那么简单。但这是它的工作原理。事件循环是交响乐的协调者。它一个接一个地运行任务。在任何给定时间，只有一个任务正在运行。

可以想象，活动任务的压力很大，因为其他任务都在等待轮到它们。因此，当活动任务发出阻塞调用（例如网络请求）并且无法取得进一步进展时，它会将控制权交还给事件循环，从而意识到其他任务可能更好地利用事件循环的时间。它还告诉事件循环它究竟被什么阻塞了，这样当网络响应到来时，事件循环可以考虑给它时间再次运行。

事件循环时间很宝贵。如果您没有取得进展，您应该退出循环，以便其他人可以。事件循环是进度的度量。

在 Python 3.5+ 中，协程暂停自身的方式是使用 await 关键字。在协程内部，当您等待另一个协程时，您会退出事件循环并安排等待的协程立即运行。也就是说，协程中的 await other_coroutine 会暂停它，并调度协程 other_coroutine 立即运行。

请注意，事件循环不会抢占正在运行的协程。只有协程可以暂停自己。

再谈协程
它们在实现上都是试图用一组少量的线程来实现多个任务，一旦某个任务阻塞，则可能用同一线程继续运行其他任务，避免大量上下文的切换。每个协程所独占的系统资源往往只有栈部分。而且，各个协程之间的切换，往往是用户通过代码来显式指定的（跟各种 callback 类似），不需要内核参与，可以很方便的实现异步。

协程本质上也是异步非阻塞技术，它是将事件回调进行了包装，让程序员看不到里面的事件循环。程序员就像写阻塞代码一样简单。比如调用 client->recv () 等待接收数据时，就像阻塞代码一样写。实际上是底层库在执行 recv 时悄悄保存了一个状态，比如代码行数，局部变量的值。然后就跳回到 EventLoop 中了。什么时候真的数据到来时，它再把刚才保存的代码行数，局部变量值取出来，又开始继续执行。

简单的说，进程 / 线程是操作系统充当了 EventLoop 调度，而协程是自己用 epoll 进行调度。

协程是异步非阻塞的另外一种展现形式。Golang，Erlang，Lua 协程都是这个模型。那什么是异步和非阻塞呢？

在网站可以找到很多对 I/O 模型进行对比和解释的文章，推荐阅读知友 严肃 对它们的 理解 （已获得授权）：

1. 同步与异步 同步和异步关注的是消息通信机制 (synchronous communication/asynchronous communication) 所谓同步，就是在发出一个 调用 时，在没有得到结果之前，该 调用 就不返回。但是一旦调用返回，就得到返回值了。 换句话说，就是由 调用者 主动等待这个 调用 的结果。

而异步则是相反， 调用 在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在 调用 发出后， 被调用者 通过状态、通知来通知调用者，或通过回调函数处理这个调用。

典型的异步编程模型比如 Node.js，举个通俗的例子： 你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，” 我查一下 "，然后开始查啊查，等查好了（可能是 5 秒，也可能是一天）告诉你结果（返回结果）。 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过 “回电” 这种方式来回调。

阻塞与非阻塞 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子， 你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己 “挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟 check 一下老板有没有返回结果。 在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

事件循环
事件循环是一种处理多并发量的有效方式，在 维基百科 中它被描述为「一种等待程序分配事件或消息的编程架构」,，我们可以定义事件循环来简化使用轮询方法来监控事件。它的意义最通俗的说法就是「当 A 发生时，执行 B」。事件循环利用 poller 对象，使得程序员不用控制任务的添加、删除和事件的控制。事件循环使用回调方法来知道事件的发生。例如，有一个资源描述符 A，当一个写事件在 A 中发生就会调用一个回调函数。如下应用都实现了事件循环：

Tornado web server
Twisted
Gevent
当然也包含 asyncio，他是 asyncio 提供的「中央处理设备」，支持如下操作：

注册、执行和取消延迟调用（超时）
创建可用于多种类型的通信的服务端和客户端的 Transports
启动进程以及相关的和外部通信程序的 Transports
将耗时函数调用委托给一个线程池
单线程（进程）的架构也避免的多线程（进程）修改可变状态的锁的问题

