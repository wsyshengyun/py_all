## 七大设计原则
1, 单一职责原则
2, 里氏替换原则
3, 依赖倒转原则
4, 接口隔离原则
5, 迪米特法则
6, 开闭原则
7, 组合/聚合复用原则

### 单一职责原则
一个类负责一项职责
### 里氏替换原则  Liskov Substitution Principle
LSP 
继承与派生的规则(子类可替换父类)
### 依赖倒转原则 Dependence Inversion Principle
高层模块不应该依赖低层模块,二者都应该依赖抽象;抽象不应该依赖细节;细节应该依赖抽象;
即针对接口编程,不要针对实现编程;
### 接口隔离原则 Interface Segregation Principle
建立单一接口,不要建立庞大臃肿的接口,尽量细化接口,接口中的方法尽量少
### 迪米特法则 Demeter Principle
高内聚,低耦合
最少知道原则
### 开闭原则  Open Close Principle 
一个软件实体 如类/模块和函数应该对扩展开放/对修改关闭.
### 组合/聚合复用原则 Composite Reuse Principle
尽量使用组合和聚合少使用继承的关系来达到复用的原则;

## 24种设计模式
##一 创建型模式
### 1 抽象工厂模式 Abstract factory pattern 
提供一个接口, 用于创建相关或依赖对象的家族,而不需要指定具体的类.   
### 2, 生成器模式 Builder pattern 
使用生成器模式封闭一个产品的构造过程,并允许按步骤构造,将一个复杂的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.
### 3 工厂模式 factory method pattern 
定义了一个创建对象的接口,但由子类决定要补全化的类是哪一个,工厂方法让类把实例化推迟到子类;

### 4 原型模式 prototype pattern 
当创建给定类的过程很昂贵或很复杂时,要使用原型模式
### 5 单例模式 Singleton pattern 
确保一个类只有一个实例,并提供全局访问点.  
- 单例模式优点
1. 单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个单例对象，然后永久驻留内存中，从而极大的降低开销。

2. 获得了一个指向该实例的全局访问节点。

3. 仅在首次请求单例对象时对其进行初始化

- 单例模式缺点
1. 违反了单一职责原则
2. 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
3. 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。

### 6 多例模式 Multition pattern 
在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.  

## 二 结构型模式

### 1 适配器模式 Adapter pattern
将一个类的接口,转换成客户期望的另玫个接口,适配器让原本接口不兼容的类可以合作无间,对象适配器使用组合,类适配器使用多重继承.
- 对象适配器
- 类适配器 
### 2 桥接模式 Bridge patten 
通过此模式可以将实现和抽象放在两个不同的类层次中而使它们可以独立改变.
### 3 组合模式 composite pattern 
允许你将对象组合成树形结构来表现"整体/部分"层次结构,组合能让客户以一致的方式处理个别对象以及对象组合.
### 4 装饰者模式 decorator pattern
动态的将责任附加到对象上,若要扩展功能,装饰者提供了比继承更有弹性的替代方案.
### 5 外观模式 facade pattern
> 也叫门面模式 

提供了一个统一的接口,用来访问子系统中的一群接口,外观定义了一个高层接口,让子系统更容易使用.
### 6 亨元模式 Flyweight pattern 
如想让某个类的一个实例能用来提供许多"虚拟实例",就使用此模式
### 7 代理模式 proxy pattern 
为另一个对象提供一个替身或占位符以控制对这个对象的访问;

## 三行为型模式
### 1 责任链模式 Chain of responsibility pattern 
通过责任链模式,你可以为某个请求创建一个对象链,每个对象依序检查此请示并对其进行处理或者将它给链中的下一个对象
### 2 命令模式 command pattern 
将"请示"封闭成对象,以便使用不同的请示,队列或者日志来参数化其他对象,命令模式也支持可撤销的操作;
### 3 解释器模式 interpreter pattern 
使用解释器为语言创建解释器
### 4 迭代器模式 iterator pattern 
提供一种方法顺序访问一个聚合对象中的各个元素,而又不暴露其内部的表示;
### 5 中介模式 Mediator pattern 
使用中介者模式来集中相关对象之间复杂的沟通和控制方式;
### 6 备忘录模式  Memento pattern 
当你需要让对象返回之前的状态时(例如,你的用户请示"撤销"), 你使用备忘录模式.
### 7 观察者模式 observer pattern  
在对象之间定义一对多的依赖,这样一来,当一个对象改变状态,依赖它的对象者会收到通知,并自动更新.
### 8 状态模式 State pattern
允许对象在内部状态改变时改变它的行为,对象看起来好象改了它的类.
### 9 策略模式 strategy pattern 
定义的算法族,分别封闭起来,让它们之间可以互相替换,此模式让算法的变化独立于使用算法的客户.
### 10 模板方法模式 Termplate pattern 
在一个方法中定义一个算法的骨架,而将一些步骤延迟到子类中,模板方法使得子类可以在不改变算法结构的情况下,重新定义算法的某些步骤.
### 11 访问者模式 visitor pattern 
你想要为一个对象的组合增加新的能力,且封装并不重要时,就使用访问者模式.

## 为什么要使用设计模式?
- 代码复用性强,提高开发效率,减少开发成本最常用的方式之一
- 扩展性强,能够在原基础上的代码上开发新的功能或者需要,快速上线
- 维护便利, 好的框架转维护后,可以减少人员的投入.
# 面向对象OOP 
是一种范式,其思想理念在代码上就是将数据块及数据相关的行为封装成特殊的,名为对象的实体,同时对象实体的生成工作是基于程序员给出的一系列"蓝图",这些蓝图就是类.关于,面向对象特性的三大特征;
- 封装
- 继承
- 多态


